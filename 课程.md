# 基本数据结构

---

## bool逻辑

1. 被定义为'假'的常量：`None` And `False`。（`False`的底层是一个**类似宏定义**的常量，**一般作为数字处理**，`None`一般针对**返回空**或者对象的处理）
2. 任何数值类型的零：`0`,`0.0`,`0j`
3. 空的序列和多项集：`''`,`()`,`[]`,`range(0)`

---

## bool运算

和C语言相同，不再赘述。
主要运算：`or`, `and`, `not`（`or`和`and`属于一种**短路运算**）
注意这里的`not`和C语言中的`!`是一样的，但是`python`中没有`!`的用法

---

## 比较
|运算|含义|
|:-|:-|
|<|严格小于|
|<= |小于或等于|
|>|严格大于|
|>=|大于或等于|
|==|等于|
|!= |不等于|
|`is`|对象标识|
|`is not`|否定对象标识|
注意一下字符串比较大小的时候是按位依次比较，其实就是比较第一个不相等的元素，和字符串的长度无关。比如："aaaaaa" < "acss"。

---

# 分支语句
`Python`和其他语言一样可以使用`if/else/elif`关键字判断条件实现程序分支。

---

## 循环语句

### While语句

```python
numbers = [12,37,5,42,8,3]
even = []
odd = []
while len(numbers) > 0:
    number = numbers.pop() #取出List元素
    if(number % 2 == 0):
        even.append(number) #List中加入元素
    else:
        odd.append(number)
```
最后的结果：
$odd = [3,5,37]$  
$even = [ 8,42,12]$

---

### For语句
Python中的for语句非常灵活，可以遍历任何序列(包括列表，字符串，元组等)。

```python
for i in range(8):
    print(i) # 0,1,2,3,4,5,6,7          

for i in range(0,10,2):
    print(i) # 0,2,4,6,8

for i in range(1,4):
    print(i) # 1,2,3
```
关于直男表白的代码的迭代可以这样写：、
```python
for i in range(0,len(message),2):
    ......
```
**注意：**
range 不返回列表！返回的是一个迭代器
$type(range) = range$
如果需要用`range`得到一个列表，可以类型转换`a = list(range(0,6,2))`或者`a = [x for x in range(0,6,2)]`

---

### break,continue,else
`break`用于跳出循环，`continue`用于忽略当此循环剩下的语句直接进行下次循环。Python中也有`else`语句，在执行完整个循环后 会执行`else`的内容，如果`break`跳出，则不会执行。
```python
for n in range(2,10):
    for x in range(2,n):
        if n % x == 0:
            print(n,'equals',x,'*',n // x)
            break
    else: #如果上述循环终止，那就不会执行这个else语句
        print(n," is a prime number")
```

---

### Pass语句
`pass`什么都不做，但是如果按`Ctrl + c`会跳出循环或者程序，经常用来占位。先留着一个空的位置以后再实现具体作用。

---

## 函数
`Python`中用`def`来定义函数。
```python
def calc(a,b):
    c = a + b
    return c
```
如果不写函数的返回值，系统自动返回`None`

---

### 函数实现递归
```cpp
def Fibonaci(n):
    if n == 0 :
        return 0
    elif n == 1:
        return 1
    else:
        return Fibonaci(n - 1) + Fibonaci(n - 2)
```
但是注意递归的**空间时间消耗会很大**。

---

这是另外的一种写法：
```python
def fib_loop(n):
    a,b = 0,1
    while a < n:
        print(a,end = ' ')
        a,b = b,a + b 
    print()

n = (int)(input())
fib_loop(n)

```

---

## 参数默认值
`Python`中的函数**可以设定参数的默认值**，具有默认值的参数在函数调用时可以不传值。没有默认值的参数为函数的**必选参数**，拥有默认值的参数为函数的**可选参数**。
```python
def countdown(start,end = 0):
    while start > end:
        start -= 1
        print(start)

if __name__ == "__main__":
    # countdown()
    countdown(100)
    countdown(start =  5)
```

---

## 任意个数个参数
`Python`中在定义函数时，可以通过在参数前面加上`*`来表示任意个数的参数。

```python
def concat(*args,sep = ' '): #这里的sep是分隔符哦~
    print(type(args)) #元组
    return sep.join(args) #字符串拼接

print(concat('abc','def','123'))
```

---

## Lambda匿名函数
Python中可以使用lambda关键字来创建一个匿名函数，属于**语法糖**
```python
pairs = [(1,'one'),(2,'two'),(3,'thre'),(4,'four')]
pairs.sort(key = lambda p : p[0])
print(pairs)
```
同义写法：
```python
def cmd(p):
    return p[0]

pairs = [(1,'one'),(2,'two'),(3,'thre'),(4,'four')]
pairs.sort(key = cmd)
print(pairs)
```
# 数据结构进阶

---
## 列表进阶操作

列表的基本操作： **增加**，**更新**，**查找**和其他。

### 增加内容

|操作|返回值|
|:-|:-|
|`L *= n`|序列重放n次并存入原序列|
|`L.append(x)`|将x追加到序列尾部|
|`L.extend(t)`or `L += t`|将列表L后面追加t输出的所有项|
|`L.insert(i,x)`|在列表的索引处i插入元素x|

**注意：** 
- 这里一定要区分`L.append(x)`和`L.extend(t)`的区别,给出一个代码解释：
```python
L = [1,2,3]

L.append([4,5])

print(L) #L = [1,2,3,[4,5]]

L = [1,2,3]

L.extend([4,5])

print(L) #L = [1,2,3,4,5]s
```
注意这两个写法的输出,`append`相当于把其中的参数当作一个量对待，而不管其中的参数是`list`还是其他。

- 对于`inset()`函数，他的效率并不高。

- `extend(t)`中的对象不一定是`list`，可以是其他**可迭代**的对象

### 更新内容

|操作|返回值|
|:-|:-|
|`L[start:end] = t`|将`start:end`的部分替换成`t`|
|`L[start:end:step] = t`|按步长`step`替换`start : end`为`t`|
|`L.sort(key = None,reverse = False)`|对列表L进行排序，可以通过key来确定顺序的键值，默认升序|
|`L.reverse()`|反转列表中的元素的顺序|

**注意：** 
- 第一步操作中的替换，`t`的长度可以不为$end - start + 1$
- 第二步中的操作，`t`的长度需要和列表所取的元素数量一致。（取决于`step`的大小）
- `L.sort()` **不返回任何值！！** 修改的内容是列表本身，这和`append()`和`extend()`及`insert()`函数一致
- `t`仍然是可迭代对象。

### 查找内容

|操作|返回值|
|:-|:-|
|`x in L`|`True/False`|
|`x not in L`|`True/False`|
|`min(L)`|返回`L`中的**最小值**|
|`max(L)`|返回`L`中的**最大值**|
|`L.index(x[,start[,end]])`|返回`x`在`L`中**第一次出现的下标**，可查找指定范围为`[start,end)`|
|`L.count(x)`|返回`x`在`L`中出现的次数|

**Question:**
`index()`函数加入范围的用法？

### 其他操作

|操作|返回值|
|:-|:-|
|`L.copy()`或`L[:]`|返回一个和L完全相同的列表（**注意这里有返回值！**）|
|`L * n`|列表重复n次（**同样带有返回值**）|
|`L.pop(i)`|删除索引为`i`的元素并返回，无参时返回最后一个元素|
|`L.remove(x)`|删除第一个**值为x**的元素（**注意这里不是下标了！**）|
|`L.clear()`|**删除**列表的所有元素|
|`del L[start : end]`|删除对应部分的元素|
|`del L[start : end : step]`|删除相应部分，**有步长**|
|`del L`|删除列表（**是直接把L删除掉，恢复到未定义状态**）|
